// Code generated by MockGen. DO NOT EDIT.
// Source: fileio.go
//
// Generated by this command:
//
//	mockgen -source=fileio.go -destination=mock_fileio.go -package=fileio
//

// Package fileio is a generated GoMock package.
package fileio

import (
	fs "io/fs"
	reflect "reflect"

	v1beta1 "github.com/flightctl/flightctl/api/v1beta1"
	fileio "github.com/flightctl/flightctl/pkg/fileio"
	gomock "go.uber.org/mock/gomock"
)

// MockManagedFile is a mock of ManagedFile interface.
type MockManagedFile struct {
	ctrl     *gomock.Controller
	recorder *MockManagedFileMockRecorder
}

// MockManagedFileMockRecorder is the mock recorder for MockManagedFile.
type MockManagedFileMockRecorder struct {
	mock *MockManagedFile
}

// NewMockManagedFile creates a new mock instance.
func NewMockManagedFile(ctrl *gomock.Controller) *MockManagedFile {
	mock := &MockManagedFile{ctrl: ctrl}
	mock.recorder = &MockManagedFileMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManagedFile) EXPECT() *MockManagedFileMockRecorder {
	return m.recorder
}

// Exists mocks base method.
func (m *MockManagedFile) Exists() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockManagedFileMockRecorder) Exists() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockManagedFile)(nil).Exists))
}

// IsUpToDate mocks base method.
func (m *MockManagedFile) IsUpToDate() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUpToDate")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUpToDate indicates an expected call of IsUpToDate.
func (mr *MockManagedFileMockRecorder) IsUpToDate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUpToDate", reflect.TypeOf((*MockManagedFile)(nil).IsUpToDate))
}

// Path mocks base method.
func (m *MockManagedFile) Path() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Path")
	ret0, _ := ret[0].(string)
	return ret0
}

// Path indicates an expected call of Path.
func (mr *MockManagedFileMockRecorder) Path() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Path", reflect.TypeOf((*MockManagedFile)(nil).Path))
}

// Write mocks base method.
func (m *MockManagedFile) Write() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write")
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockManagedFileMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockManagedFile)(nil).Write))
}

// MockManagedWriter is a mock of ManagedWriter interface.
type MockManagedWriter struct {
	ctrl     *gomock.Controller
	recorder *MockManagedWriterMockRecorder
}

// MockManagedWriterMockRecorder is the mock recorder for MockManagedWriter.
type MockManagedWriterMockRecorder struct {
	mock *MockManagedWriter
}

// NewMockManagedWriter creates a new mock instance.
func NewMockManagedWriter(ctrl *gomock.Controller) *MockManagedWriter {
	mock := &MockManagedWriter{ctrl: ctrl}
	mock.recorder = &MockManagedWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManagedWriter) EXPECT() *MockManagedWriterMockRecorder {
	return m.recorder
}

// CopyDir mocks base method.
func (m *MockManagedWriter) CopyDir(src, dst string, opts ...fileio.CopyDirOption) error {
	m.ctrl.T.Helper()
	varargs := []any{src, dst}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyDir", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyDir indicates an expected call of CopyDir.
func (mr *MockManagedWriterMockRecorder) CopyDir(src, dst any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{src, dst}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyDir", reflect.TypeOf((*MockManagedWriter)(nil).CopyDir), varargs...)
}

// CopyFile mocks base method.
func (m *MockManagedWriter) CopyFile(src, dst string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyFile", src, dst)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyFile indicates an expected call of CopyFile.
func (mr *MockManagedWriterMockRecorder) CopyFile(src, dst any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyFile", reflect.TypeOf((*MockManagedWriter)(nil).CopyFile), src, dst)
}

// CreateManagedFile mocks base method.
func (m *MockManagedWriter) CreateManagedFile(file v1beta1.FileSpec) (ManagedFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateManagedFile", file)
	ret0, _ := ret[0].(ManagedFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateManagedFile indicates an expected call of CreateManagedFile.
func (mr *MockManagedWriterMockRecorder) CreateManagedFile(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateManagedFile", reflect.TypeOf((*MockManagedWriter)(nil).CreateManagedFile), file)
}

// MkdirAll mocks base method.
func (m *MockManagedWriter) MkdirAll(path string, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockManagedWriterMockRecorder) MkdirAll(path, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockManagedWriter)(nil).MkdirAll), path, perm)
}

// MkdirTemp mocks base method.
func (m *MockManagedWriter) MkdirTemp(prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirTemp", prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MkdirTemp indicates an expected call of MkdirTemp.
func (mr *MockManagedWriterMockRecorder) MkdirTemp(prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirTemp", reflect.TypeOf((*MockManagedWriter)(nil).MkdirTemp), prefix)
}

// OverwriteAndWipe mocks base method.
func (m *MockManagedWriter) OverwriteAndWipe(file string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OverwriteAndWipe", file)
	ret0, _ := ret[0].(error)
	return ret0
}

// OverwriteAndWipe indicates an expected call of OverwriteAndWipe.
func (mr *MockManagedWriterMockRecorder) OverwriteAndWipe(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OverwriteAndWipe", reflect.TypeOf((*MockManagedWriter)(nil).OverwriteAndWipe), file)
}

// PathFor mocks base method.
func (m *MockManagedWriter) PathFor(filePath string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathFor", filePath)
	ret0, _ := ret[0].(string)
	return ret0
}

// PathFor indicates an expected call of PathFor.
func (mr *MockManagedWriterMockRecorder) PathFor(filePath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathFor", reflect.TypeOf((*MockManagedWriter)(nil).PathFor), filePath)
}

// RemoveAll mocks base method.
func (m *MockManagedWriter) RemoveAll(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAll", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAll indicates an expected call of RemoveAll.
func (mr *MockManagedWriterMockRecorder) RemoveAll(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAll", reflect.TypeOf((*MockManagedWriter)(nil).RemoveAll), path)
}

// RemoveContents mocks base method.
func (m *MockManagedWriter) RemoveContents(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveContents", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveContents indicates an expected call of RemoveContents.
func (mr *MockManagedWriterMockRecorder) RemoveContents(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveContents", reflect.TypeOf((*MockManagedWriter)(nil).RemoveContents), path)
}

// RemoveFile mocks base method.
func (m *MockManagedWriter) RemoveFile(file string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveFile", file)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveFile indicates an expected call of RemoveFile.
func (mr *MockManagedWriterMockRecorder) RemoveFile(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFile", reflect.TypeOf((*MockManagedWriter)(nil).RemoveFile), file)
}

// SetRootdir mocks base method.
func (m *MockManagedWriter) SetRootdir(path string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRootdir", path)
}

// SetRootdir indicates an expected call of SetRootdir.
func (mr *MockManagedWriterMockRecorder) SetRootdir(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRootdir", reflect.TypeOf((*MockManagedWriter)(nil).SetRootdir), path)
}

// WriteFile mocks base method.
func (m *MockManagedWriter) WriteFile(name string, data []byte, perm fs.FileMode, opts ...fileio.FileOption) error {
	m.ctrl.T.Helper()
	varargs := []any{name, data, perm}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteFile", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockManagedWriterMockRecorder) WriteFile(name, data, perm any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name, data, perm}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockManagedWriter)(nil).WriteFile), varargs...)
}

// MockManagedReadWriter is a mock of ManagedReadWriter interface.
type MockManagedReadWriter struct {
	ctrl     *gomock.Controller
	recorder *MockManagedReadWriterMockRecorder
}

// MockManagedReadWriterMockRecorder is the mock recorder for MockManagedReadWriter.
type MockManagedReadWriterMockRecorder struct {
	mock *MockManagedReadWriter
}

// NewMockManagedReadWriter creates a new mock instance.
func NewMockManagedReadWriter(ctrl *gomock.Controller) *MockManagedReadWriter {
	mock := &MockManagedReadWriter{ctrl: ctrl}
	mock.recorder = &MockManagedReadWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManagedReadWriter) EXPECT() *MockManagedReadWriterMockRecorder {
	return m.recorder
}

// CopyDir mocks base method.
func (m *MockManagedReadWriter) CopyDir(src, dst string, opts ...fileio.CopyDirOption) error {
	m.ctrl.T.Helper()
	varargs := []any{src, dst}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyDir", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyDir indicates an expected call of CopyDir.
func (mr *MockManagedReadWriterMockRecorder) CopyDir(src, dst any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{src, dst}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyDir", reflect.TypeOf((*MockManagedReadWriter)(nil).CopyDir), varargs...)
}

// CopyFile mocks base method.
func (m *MockManagedReadWriter) CopyFile(src, dst string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyFile", src, dst)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyFile indicates an expected call of CopyFile.
func (mr *MockManagedReadWriterMockRecorder) CopyFile(src, dst any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyFile", reflect.TypeOf((*MockManagedReadWriter)(nil).CopyFile), src, dst)
}

// CreateManagedFile mocks base method.
func (m *MockManagedReadWriter) CreateManagedFile(file v1beta1.FileSpec) (ManagedFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateManagedFile", file)
	ret0, _ := ret[0].(ManagedFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateManagedFile indicates an expected call of CreateManagedFile.
func (mr *MockManagedReadWriterMockRecorder) CreateManagedFile(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateManagedFile", reflect.TypeOf((*MockManagedReadWriter)(nil).CreateManagedFile), file)
}

// MkdirAll mocks base method.
func (m *MockManagedReadWriter) MkdirAll(path string, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockManagedReadWriterMockRecorder) MkdirAll(path, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockManagedReadWriter)(nil).MkdirAll), path, perm)
}

// MkdirTemp mocks base method.
func (m *MockManagedReadWriter) MkdirTemp(prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirTemp", prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MkdirTemp indicates an expected call of MkdirTemp.
func (mr *MockManagedReadWriterMockRecorder) MkdirTemp(prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirTemp", reflect.TypeOf((*MockManagedReadWriter)(nil).MkdirTemp), prefix)
}

// OverwriteAndWipe mocks base method.
func (m *MockManagedReadWriter) OverwriteAndWipe(file string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OverwriteAndWipe", file)
	ret0, _ := ret[0].(error)
	return ret0
}

// OverwriteAndWipe indicates an expected call of OverwriteAndWipe.
func (mr *MockManagedReadWriterMockRecorder) OverwriteAndWipe(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OverwriteAndWipe", reflect.TypeOf((*MockManagedReadWriter)(nil).OverwriteAndWipe), file)
}

// PathExists mocks base method.
func (m *MockManagedReadWriter) PathExists(path string, opts ...fileio.PathExistsOption) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{path}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PathExists", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PathExists indicates an expected call of PathExists.
func (mr *MockManagedReadWriterMockRecorder) PathExists(path any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{path}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathExists", reflect.TypeOf((*MockManagedReadWriter)(nil).PathExists), varargs...)
}

// PathFor mocks base method.
func (m *MockManagedReadWriter) PathFor(filePath string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathFor", filePath)
	ret0, _ := ret[0].(string)
	return ret0
}

// PathFor indicates an expected call of PathFor.
func (mr *MockManagedReadWriterMockRecorder) PathFor(filePath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathFor", reflect.TypeOf((*MockManagedReadWriter)(nil).PathFor), filePath)
}

// ReadDir mocks base method.
func (m *MockManagedReadWriter) ReadDir(dirPath string) ([]fs.DirEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDir", dirPath)
	ret0, _ := ret[0].([]fs.DirEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadDir indicates an expected call of ReadDir.
func (mr *MockManagedReadWriterMockRecorder) ReadDir(dirPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDir", reflect.TypeOf((*MockManagedReadWriter)(nil).ReadDir), dirPath)
}

// ReadFile mocks base method.
func (m *MockManagedReadWriter) ReadFile(filePath string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", filePath)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockManagedReadWriterMockRecorder) ReadFile(filePath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockManagedReadWriter)(nil).ReadFile), filePath)
}

// RemoveAll mocks base method.
func (m *MockManagedReadWriter) RemoveAll(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAll", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAll indicates an expected call of RemoveAll.
func (mr *MockManagedReadWriterMockRecorder) RemoveAll(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAll", reflect.TypeOf((*MockManagedReadWriter)(nil).RemoveAll), path)
}

// RemoveContents mocks base method.
func (m *MockManagedReadWriter) RemoveContents(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveContents", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveContents indicates an expected call of RemoveContents.
func (mr *MockManagedReadWriterMockRecorder) RemoveContents(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveContents", reflect.TypeOf((*MockManagedReadWriter)(nil).RemoveContents), path)
}

// RemoveFile mocks base method.
func (m *MockManagedReadWriter) RemoveFile(file string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveFile", file)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveFile indicates an expected call of RemoveFile.
func (mr *MockManagedReadWriterMockRecorder) RemoveFile(file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFile", reflect.TypeOf((*MockManagedReadWriter)(nil).RemoveFile), file)
}

// SetRootdir mocks base method.
func (m *MockManagedReadWriter) SetRootdir(path string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRootdir", path)
}

// SetRootdir indicates an expected call of SetRootdir.
func (mr *MockManagedReadWriterMockRecorder) SetRootdir(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRootdir", reflect.TypeOf((*MockManagedReadWriter)(nil).SetRootdir), path)
}

// WriteFile mocks base method.
func (m *MockManagedReadWriter) WriteFile(name string, data []byte, perm fs.FileMode, opts ...fileio.FileOption) error {
	m.ctrl.T.Helper()
	varargs := []any{name, data, perm}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteFile", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockManagedReadWriterMockRecorder) WriteFile(name, data, perm any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name, data, perm}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockManagedReadWriter)(nil).WriteFile), varargs...)
}
